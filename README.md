# Redis笔记

## 底层数据结构

### ZipList

ZipList在使用连续内存空间尽可能的按需求大小存储string/[]byte/int。

- 本质上是[]byte，性质上则更像链表。通过Encoding字段获取当前元素的长度从而指向下个元素，
通过PrevLength字段获取上个元素的长度从而指向上个元素。
- 可以存储不定长的[]byte和int，极为节约内存。
- int查找O(n)、string/[]byte查找O(mn)、插入尾端O(1)，插入指定位置最坏O(n^2)，因为会连锁导致后续元素长度变更。

**相比传统的LinkedList好处在哪呢？**
节约内存、高效遍历（连续内存空间搭配缓存行真好吃）。

### IntSet

IntSet旨在使用连续内存空间存储排序好的整数。

- 本质上还是[]byte，元素占用内存范围根据集合全局整数类型升级。比如一开始是int8，当插入一个int16就升级了。
- 内部排序好的，所以查找O(logn)，插入O(n)，查找指定位置O(1)

**相比传统的[]int的好处在哪呢？**
节约内存！相当于[]int16 <-> []int32 <-> []int64

### QuickList

QuickList是节点为ZipList的链表。平衡了存储效率和查询效率。

**相比传统的LinkedList好处在哪呢**
链表节点为ZipList，有着ZipList的优点。但是我们也知道ZipList插入指定位置当发生连锁更新的时候时间复杂度变高，
但是传统链表不会。所以QuickList限制每个节点的ZipList最多可以插入n个元素或者大小为m bytes的元素，然后就要
产生新的链表节点了。所以是一种很好的平衡

### Dict

- Java的是达到负载因子（默认0.75）后扩容的，而dict是达到1或者达到默认5扩容的。
- 扩容以后的重哈希的过程分散在了增删改查各个操作之中，降低了原本产生扩容操作的耗时。
- 并没有链表转红黑树的操作，所以如对于哈希碰撞十分严重的桶，查询效率较低。

**相比传统的HashTable好处在哪呢**
渐进式重哈希真的很平滑！

### SkipList

跳跃表，是一种可以用来代替平衡树的数据结构，它采取了概率平衡而不是严格强制的平衡。

- 插入、删除、查询平均O(logn)，和平衡树相同

**相比传统的平衡树好处在哪呢**
范围查找很轻松，因为每个节点都有一个向后指针，所以先查询到右范围节点，然后向左遍历即可。

## 对象

### STRING

### LIST

底层实现为QuickList，没啥好说的

### HASH

底层实现为ZipList或者Dict。你懂的，数量少的话ZipList就完事了，遍历也很快。

### SET

底层实现为IntSet和Dict。你懂的，整数和数量少嘛就前者。

### ZSET

底层实现为ZipList和SkipList。数量少的话就用ZipList，但是为了保证有序是不能直接尾插的，要先遍历到能插入的地方。